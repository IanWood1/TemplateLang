# TemplateLang
TemplateLang is a language within C++ that uses templates for calculations at both runtime and compile time. Goal of the mini-project was to explore C++ templates and explore what can be done with them.


## Usage
### Types
Each object that can be used in TemplateLang corresponds to 3 types:
- `Expression` - evaluatable to a double
	- Implements `operator()` for calling the expression
- `Generator` - generates a list of doubles
	- Implements `operator()` for getting the next value
	- Implements `is_done()` for checking if values have been exhausted
- `Function` - is callable by other objects
	- Implements `operator()` for getting a program object from function

***__Note__***: These are not C++ types, but rather types within TemplateLang. They are implemented using structs in C++.

### Expressions
Expressions are evaluatable to a single double and can be composed of multiple expressions. Both `variable` and `value` are expressions. Additionally, `add` and other operators are expressions.

Although `function` is not an expression, calling it using `call` will result in an expression. `call` takes in a function and a list of expressions to pass to the function. The function must be a TemplateLang `Function` type.

Here is an expression that finds the difference of squares of two variables:
```cpp
add<
  mul<variable<0>, variable<0>>, 
  neg<
    mul<variable<1>, variable<1>>>
```

### Functions
Functions can be created by using the function struct: `function<Expression, num_params>` . The `Expression` template parameter is the body of the function, the `num_params` template parameter tells the function how many variables to use. The `Expression` template parameter can be any ***__Expression__***. A variable used in the body is in a new scope, but must be declared

A function to add two variables can be created like this:
```cpp
function<add<variable<0>, variable<1>>, 2> adder;
```

Calling the function can be done using `call`, which results in an expression:
```cpp
call<adder, variable<0>, variable<1>>
```

### Generators
Generators are objects that generate a list of doubles, and are composable to create new generators. Currently, only one generator -> expression is implemented: `sum`. `compose` is used similar to map, it applies a function to each elem generated by the given generator.

The expression `reduce` should probably take a generator instead of iterating over a range.



### Creating a Program
A program in TemplateLang starts with `template<class Body, int64_t> struct program`, instantiating this object and calling `double program::run(double args...)` will run the program. The `Body` template parameter is an ***__Expression__*** representing body of the program, the `int64_t` template arg tells the program how many outside variables to expect.

Each program (they can be nested because functions spawn new programs) contains a `std::vector<double>` that is used for storing outside variables. The `double program::run(double args...)` function takes in the outside variables as arguments and stores them in the vector.

Currently, variables accessed by index, so `variable<0` is the first variable passed to `run()`.


## Examples

### 
```cpp
double sequence_sum_reduce(double x) {

  // sum from 1 to n
  using f = function<
              reduce_range<
                function<
                  add<variable<0>, variable<1>>, 
                  2>,
                value<1>, 
                add<value<1>, variable<0>>>,
              1>;

  return program<
              call<f, variable<0>>, 
              1>{}.run(x);
}
```

### Fibonacci
```cpp
double fib_recursive(double x) {
  using f = function<
              if_<
                lteq<variable<0>, value<1>>, 
                variable<0>,
                add<
                  recurse<add<variable<0>, value<-1>>>,
                  recurse<add<variable<0>, value<-2>>>>>,
              1>;
  return program<
            call<f, variable<0>>, 
            1>{}.run(x);
}
```

### e approximation
```cpp
double e_approx(double n_terms) {
  using range_gen = gen<
		                function<variable<0>, 1>,
		                value<0>,
		                add<value<1>, variable<0>>>;
  
  using f_factorial = function<
												reduce_range<
													function<
														mul<variable<0>, variable<1>>, 
														2>,
													value<1>, 
													add<value<1>, variable<0>>, 
                          value<1>>,
												1>;
  using fact_gen = compose<
										range_gen, 
										f_factorial>;
  using inv_gen = compose<
                    fact_gen, 
                    function<
                      inv<variable<0>>, 
                      1>>;
  return program<sum<inv_gen>, 1>{}.run(n_terms); 
}
```